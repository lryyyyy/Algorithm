# Algorithm
Algorithm

0-1背包问题

有n个重量和价值分别为wi，vi的物品，从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。

这是被称为背包问题的一个著名问题。这个问题怎么求解好呢？这个问题是我遇到的第一个动规问题，最开始做的时候并不知道动规的思想，所以直接使用了最简单的方法：对每个物品是否放入背包进行枚举，然后对所有情况求最大值。
枚举的规律很简单，只需要分三种情况：

1：已经没有剩余的物品了，直接return 0

    if (i == n)
      res = 0;

2：如果挑选了这个物品重量就会超出限制，跳过这个物品

    else if (j < w[i])
      res = rec(i+1,j,w,v);

3：如果可以挑选这个物品，只需要把挑选和不挑选都尝试一下就好了。

    else
      res = max(rec(i+1,j,w,v), rec(i+1,j-w[i],w,v)+v[i]);

于是，就有了第一版的0-1背包代码

但是这种方法的搜索深度是n，而且每层的搜索有需要两次分支，最坏情况下就需要O(2^n)的时间复杂度，当n比较大时就不具有可执行性了。怎么办才好呢？当我们分析程序的执行过程时，我们发现有很多值出现了多次，由于栈与栈的相互独立原理，每次计算都是与其他计算无关的。所以我们可以把第一次计算的结果给记录下来，省略掉第二次以后的重复计算试试看。
那么就模拟一个二维数组，由于一共n个物品，可以带走的总重量不超过W，所以就创建一个n*W的数组，并通过宏定义将其模拟为二维数组，将每个数第一次的计算结果记录下来。在函数调用时，如果发现结果已经计算过的话就直接使用之前计算的结果。

先创建一个数组，这里dp数组是个一维数组，用宏模拟成了二维数组(我不太喜欢二维数组)，其中length是第一维的长度

    #define dp(M,N,length)  dp[(M)*(length)+(N)]
    int sdp = n * W;
    int * dp = (int *)malloc(sdp * sizeof(int));
    memset(dp,-1,sdp * sizeof(int));

然后在求解时先查看dp数组中是否有记录，如果有记录就直接返回dp数组的值，如果没有记录再递归求解

    if (dp(i,j,W) >= 0)
      return dp(i,j,W);

于是第二版的0-1背包代码也就出来了。这样就通过记忆优化和递归的方式实现了对问题的求解。
这样微小的改动到底带来了多少速度呢？对于同样的参数，只会在第一次调用时执行递归部分，第二次调用时就可以直接在数组中找到对应的值。参数的组合不超过nW种，所以只需要O(nW)的时间就能解决这个问题。

当然，我们可以用非递归替换递归，这样子就不需要入栈出栈操作，程序的运行速度就可以进一步提高。非递归与递归没有太大差别，所以第二个程序写出来后，就可以直接站撸非递归算法了，写法很简单，在数组里循环求解就行了。

    for (int i = 0; i < n; i++)
      {
        for (int j = 0; j <= W; j++)
        {
          if (j < w[i])
            dp(i+1,j,W) = dp(i,j,W);
          else
            dp(i+1,j,W) = max(dp(i,j,W),dp(i,j-w[i],W)+v[i]);
        }
      }
      return dp(n,W-1,W);

最后返回dp[n,W-1]的值就好了。这样第三版的0-1背包代码就搞定了。

至于第四版的代码，更简洁了，直接将二维数组优化成了一维数组.
由

    dp(i+1,j,W) = dp(i,j,W);
    dp(i+1,j,W) = max(dp(i,j,W),dp(i,j-w[i],W)+v[i]);
    
可以得出dp的当前值[i+1,j]一定是由上一行的当前列[i,j]或者上一行的[i,j-w[i]](这一列在当前列的左边)得出的，所以可以从右往左依次计算，用一维数组循环就可以得到。

      for (int i = 0; i < n; i++)
      {
        for (int j = W; j >= w[i]; j--)
        {
          dp[j] = max(dp[j], dp[j-w[i]]+v[i]);
        }
      }
      return dp[W];

至于第五版的代码，鬼知道我写的是个什么玩意，等我看懂了再来更新吧~~~



第五版代码的思路完全是另一种解题思路，思路是前面几种解法思路的逆向。
前面几种解法的思路是用背包的重量W作为动规的条件，判断在当前背包重量W下，最多能装多少价值的物品；而第五版的思路是用价值V作为动规的条件，判断最少需要多少重量可以达成当前价值。注意看代码：

    if (j < v[i])
        dp(i+1,j,len) = dp(i,j,len);
    else
        dp(i+1,j,len) = min(dp(i,j,len),dp(i,j-v[i],len)+w[i]);

这里dp数组里放的不是价值，而是重量！！！达成当前价值的最小重量！！！
可以看一看数组最后一行的值：

input:  5 10
        2 6
        2 3
        4 6
        6 5
        5 4
        
output: 0   999   999     2     5     6     2     7     8     4     7     8     6     9    10     #8    11    12    15    13    14    17   999   999    19   999   999   999   999   999   999

这里，返回的值是15，但是这个15绝不是数组中的15，而是从后往前数，数到的第一个小于等于W(这组数据中W为10)的值的下标(就是前面带#的那个8的下标)

就酱~~~
